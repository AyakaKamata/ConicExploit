## 概要
7/21に起こった[Conic Finance](https://conic.finance/)に対しての攻撃の一つ、[ETH Omnipool exploit:0x8b74995d1d61d3d7547575649136b8765acb22882960f0636941c44ec7bbe146](https://explorer.phalcon.xyz/tx/eth/0x8b74995d1d61d3d7547575649136b8765acb22882960f0636941c44ec7bbe146)を解析しました。Reentrancy攻撃でlpTokenの価格操作を行っています。
参考：[Post Mortem-ETH and crvUSD Omnipool Exploits](https://medium.com/@ConicFinance/post-mortem-eth-and-crvusd-omnipool-exploits-c9c7fa213a3d)

## 使ったもの
[Phalcon](https://explorer.phalcon.xyz/), [Etherscan](https://etherscan.io/), [Foundry](https://book.getfoundry.sh/), [Solidity](https://docs.soliditylang.org/en/latest/)

## PoC
foundryのtestです。
```bash:test.sh
export ETHERSCAN_API_KEY = < your key >
forge test --mc ConicTest -vvv
```

## 攻撃の概要
Flash Loanにより、Attackerの残高は以下の図のようになっています。

[引用元](https://gist.github.com/minaminao/68e45ec8211866f3fe8f3446c7c4c6cf)

```mermaid
sequenceDiagram
    participant ConicETH
    participant Attacker
    participant WETH-rETH
    participant WETH-cbETH
    participant ETH-stETH

    Note over Attacker: 残高<br>WETH: 28504.2 ether<br>rETH: 20550 ether<br>cbETH: 3850 ether<br>stETH: 19999.9... ether

    loop 7回繰り返す
    	Attacker -) ConicETH: 1214 WETH deposit
    	Attacker -) WETH-cbETH: 121 cbETHをWETHにexchange
    	Attacker -) WETH-rETH: 121 rETHをWETHにexchange
    end

    rect rgb(60,60,0,0.2)
    Attacker -) ETH-stETH: 20000 ETHをadd_liquidity
    Attacker ->>+ ETH-stETH: 全て remove_liquidity
    ETH-stETH ->>+ Attacker: Ether送金
    Attacker -) ConicETH: ETH-stETHをhandleDepeggedCurvePool
    Attacker -->>- ETH-stETH: end of Ether送金
    ETH-stETH -->>- Attacker: end of remove_liquidity
    end

    rect rgb(0, 60, 60,0.2)
    Attacker -) WETH-cbETH: cbETHを全額WETHにexchange
    Attacker -) WETH-cbETH:  1.8 WETHをadd_liquidity
    Attacker ->>+ WETH-cbETH: 全て remove_liquidity
    WETH-cbETH ->>+ Attacker: Ether送金
    Attacker -) ConicETH: WETH-cbETHをhandleDepeggedCurvePool
    Attacker -->>- WETH-cbETH: end of Ether送金
    WETH-cbETH -->>- Attacker: end of remove_liquidity
    end

    rect rgb(60, 0, 60,0.2)
    Attacker -) WETH-cbETH: 2105 WETHをcbETHにexchange
    Attacker -) WETH-rETH: 19703 rETHをWETHにexchange
    Attacker -) WETH-rETH: 2.4 WETHをadd_liquidity
    Attacker ->>+ WETH-rETH: remove_liquidity
    WETH-rETH ->>+ Attacker: Ether送金
    Attacker ->>+ ConicETH: 6292 cncETH分withdraw
    ConicETH -) WETH-cbETH: remove_liquidity_one_coin via CurveHandler
    ConicETH -) ETH-stETH: remove_liquidity_one_coin via CurveHandler
    ConicETH -->>- Attacker: end of withdraw
    Attacker -->>- WETH-rETH: end of Ether送金
    WETH-rETH -->>- Attacker: end of remove_liquidity
    end

    rect rgb(60, 60, 60,0.2)
    Attacker -) WETH-rETH: 3450 WETHをrETHにexchange
    Attacker -) WETH-cbETH: 850 WETHをcbETHにexchange
    Attacker -) ConicETH: 残りのcncETH分withdraw
    end
```

ループの中で少しずつConicにWETHをデポジットし、rETH,cbETH,stETHの価格を釣り上げます。Poolのバランスを維持するために、exchangeをしています。

そして、Curveに対して、addLiquidityしたあと、removeLiquidityをすることでReentrancy Attackが可能になります。これは、removeLiquidityの引数であるuse_ethがtrueのときは、WETHではなくETHを返すためです。
```Vyper:Vyper_contract.vy
@external
@nonreentrant('lock')
def remove_liquidity(_amount: uint256, min_amounts: uint256[N_COINS],
                     use_eth: bool = False, receiver: address = msg.sender):
    """
    This withdrawal method is very safe, does no complex math
    """
    lp_token: address = self.token
    total_supply: uint256 = CurveToken(lp_token).totalSupply()
    CurveToken(lp_token).burnFrom(msg.sender, _amount)
    balances: uint256[N_COINS] = self.balances
    amount: uint256 = _amount - 1  # Make rounding errors favoring other LPs a tiny bit

    for i in range(N_COINS):
        d_balance: uint256 = balances[i] * amount / total_supply
        assert d_balance >= min_amounts[i]
        self.balances[i] = balances[i] - d_balance
        balances[i] = d_balance  # now it's the amounts going out
        coin: address = self.coins[i]
        if use_eth and coin == WETH20:
            raw_call(receiver, b"", value=d_balance)
        else:
            if coin == WETH20:
                WETH(WETH20).deposit(value=d_balance)
            response: Bytes[32] = raw_call(
                coin,
                _abi_encode(receiver, d_balance, method_id=method_id("transfer(address,uint256)")),
                max_outsize=32,
            )
            if len(response) != 0:
                assert convert(response, bool)

    D: uint256 = self.D
    self.D = D - D * amount / total_supply

    log RemoveLiquidity(msg.sender, balances, total_supply - _amount)

```

そしてConicに対してhandleDepeggedCurvePool関数を実行することで、withdraw時にweight0のプールが優先的に引き出し対象に選ばれるようになります。これにより、WETH-rETHプールが引き出し対象になってreentrancy Lockがかかるのを防ぎます。

```solidity:ConicEthPool.sol
    function handleDepeggedCurvePool
        /// @notice Withdraw underlying
        /// @param conicLpAmount Amount of LP tokens to burn
        /// @param minUnderlyingReceived Minimum amount of underlying to redeem
        /// This should always be set to a reasonable value (e.g. 2%), otherwise
        /// the user withdrawing could be forced into paying a withdrawal penalty fee
        /// by another user
        /// @return uint256 Total underlying withdrawn
        function withdraw(
            uint256 conicLpAmount,
            uint256 minUnderlyingReceived
        ) public override returns (uint256) {
            // Preparing Withdrawals
            require(lpToken.balanceOf(msg.sender) >= conicLpAmount, "insufficient balance");
            uint256 underlyingBalanceBefore_ = underlying.balanceOf(address(this));

            // Processing Withdrawals
            (
                uint256 totalUnderlying_,
                uint256 allocatedUnderlying_,
                uint256[] memory allocatedPerPool
            ) = getTotalAndPerPoolUnderlying();
            uint256 underlyingToReceive_ = conicLpAmount.mulDown(_exchangeRate(totalUnderlying_));
            {
                if (underlyingBalanceBefore_ < underlyingToReceive_) {
                    uint256 underlyingToWithdraw_ = underlyingToReceive_ - underlyingBalanceBefore_;
                    _withdrawFromCurve(allocatedUnderlying_, allocatedPerPool, underlyingToWithdraw_);
                }
            }

            // Sending Underlying and burning LP Tokens
            uint256 underlyingWithdrawn_ = _min(
                underlying.balanceOf(address(this)),
                underlyingToReceive_
            );
            require(underlyingWithdrawn_ >= minUnderlyingReceived, "too much slippage");
            lpToken.burn(msg.sender, conicLpAmount);
            underlying.safeTransfer(msg.sender, underlyingWithdrawn_);

            _cachedTotalUnderlying = totalUnderlying_ - underlyingWithdrawn_;
            _cacheUpdatedTimestamp = block.timestamp;

            emit Withdraw(msg.sender, underlyingWithdrawn_);
            _reentrancyCheck();
            return underlyingWithdrawn_;
        }

        function _withdrawFromCurve(
            uint256 totalUnderlying_,
            uint256[] memory allocatedPerPool,
            uint256 amount_
        ) internal {
            uint256 withdrawalsRemaining_ = amount_;
            uint256 totalAfterWithdrawal_ = totalUnderlying_ - amount_;

            // NOTE: avoid modifying `allocatedPerPool`
            uint256[] memory allocatedPerPoolCopy = allocatedPerPool.copy();

            while (withdrawalsRemaining_ > 0) {
                (uint256 curvePoolIndex_, uint256 maxWithdrawal_) = _getWithdrawPool(
                    totalAfterWithdrawal_,
                    allocatedPerPoolCopy
                );
                address curvePool_ = _curvePools.at(curvePoolIndex_);

                // Withdrawing from least balanced Curve pool
                uint256 toWithdraw_ = _min(withdrawalsRemaining_, maxWithdrawal_);
                _withdrawFromCurvePool(curvePool_, toWithdraw_);
                withdrawalsRemaining_ -= toWithdraw_;
                allocatedPerPoolCopy[curvePoolIndex_] -= toWithdraw_;
            }
        }

        function _getWithdrawPool(
            uint256 totalUnderlying_,
            uint256[] memory allocatedPerPool
        ) internal view returns (uint256 withdrawPoolIndex, uint256 maxWithdrawalAmount) {
            uint256 curvePoolCount_ = allocatedPerPool.length;
            int256 iWithdrawPoolIndex = -1;
            for (uint256 i; i < curvePoolCount_; i++) {
                address curvePool_ = _curvePools.at(i);
                uint256 weight_ = weights.get(curvePool_);
                uint256 allocatedUnderlying_ = allocatedPerPool[i];

                // If a curve pool has a weight of 0,
                // withdraw from it if it has more than the max lp value
                if (weight_ == 0) {
                    uint256 price_ = controller.priceOracle().getUSDPrice(address(underlying));
                    uint256 allocatedUsd = (price_ * allocatedUnderlying_) /
                        10 ** underlying.decimals();
                    if (allocatedUsd >= _MAX_USD_LP_VALUE_FOR_REMOVING_CURVE_POOL / 2) {
                        return (uint256(i), allocatedUnderlying_);
                    }
                }

                uint256 targetAllocation_ = totalUnderlying_.mulDown(weight_);
                if (allocatedUnderlying_ <= targetAllocation_) continue;
                uint256 minBalance_ = targetAllocation_ - targetAllocation_.mulDown(_getMaxDeviation());
                uint256 maxWithdrawalAmount_ = allocatedUnderlying_ - minBalance_;
                if (maxWithdrawalAmount_ <= maxWithdrawalAmount) continue;
                maxWithdrawalAmount = maxWithdrawalAmount_;
                iWithdrawPoolIndex = int256(i);
            }
            require(iWithdrawPoolIndex > -1, "error retrieving withdraw pool");
            withdrawPoolIndex = uint256(iWithdrawPoolIndex);
        }
```

## なぜReentrancy Checkが働かなかったか
Reentrancy何故起きたか
一般に、solidityやVyperの関数にはReentrancyCheckといってReentrancy攻撃を防ぐ仕組みがあります。今回の攻撃では、ReentrancyCheckがついていたにも関わらず、Reentrancy攻撃が防げませんでした。この理由は、Check-Effect-Interactionパターンに従っていなかったためです。ステートの変更前に操作を行っていたため、攻撃が可能になっていました。
